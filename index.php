<?php

namespace CTDesarrollo\SiriusApp\Controllers\Mantenimiento\Support;

use CTDesarrollo\Core\EntidadesFormativas\Models\AsignaturaVersion;
use CTDesarrollo\Core\EntidadesFormativas\Models\ProgramaVersion;
use CTDesarrollo\Core\EstructurasAcademicas\Models\NodoAcademico;
use CTDesarrollo\Core\EstructurasAcademicas\Models\NodoEducativo;
use CTDesarrollo\Core\EstructurasAcademicas\Models\NodoTransformado;
use CTDesarrollo\Core\Expedientes\Registros\Models\Admision;
use CTDesarrollo\Core\Expedientes\Registros\Models\Especializacion;
use CTDesarrollo\Core\Expedientes\Registros\Models\Inscripcion;
use CTDesarrollo\Core\Expedientes\Registros\Models\SeleccionAcademica;
use CTDesarrollo\Core\Framework\DB\Model;

use CTDesarrollo\Core\OrdenAcademico\Models\PeriodoLectivo;
use CTDesarrollo\Core\OrdenAcademico\Models\PlazaAcademica;
use CTDesarrollo\Core\OrdenAcademico\Models\Resolucion;
use CTDesarrollo\Core\OrdenAcademico\Repositories\PeriodosLectivos;
use CTDesarrollo\CoreApp\Controllers\ControllerSI;
use CTDesarrollo\CoreApp\Framework\Routing\AppController;
use CTFramework\Framework\Database\ActiveRecord\Collection;
use CTFramework\Framework\System\Loader;
use iio\libmergepdf\Exception;

use function class_basename;
use function collect;

/**
 * Class CambioAsignaturasEstructuras
 *
 * @package CTDesarrollo\SiriusApp\Controllers\Mantenimiento\Support
 *
 */
class CambioAsignaturasEstructuras extends AppController
{
    private static $response = [
        "steps" => [],
        "errors" => [],
        "status" => true
    ];

    protected function __autorize()
    {
        return true; // TODO: Change the autogenerated stub
    }

    /**
     * @return array
     *
     * @throws \Exception
     */
    public function handleEvent()
    {
        $payload = $this->getRequest()->getParsedBody();

        switch ($payload['event']) {
            case 'add':
                $this->proccessAddSubject($payload['data']);
                break;
            case 'update':
                $this->processUpdateSubject($payload['data']);
                break;
            case 'verifyUpdate':
                $this->verifySubjectGradeTransfer($payload['data']);
                break;
            case 'updateModule':
                $this->processUpdateModuleSubject($payload['data']);
                break;
            case 'updateOptative':
                $this->processUpdateOptative($payload['data']);
                break;
        }

        return self::$response;
    }

    /**
     * Procesa la adicion de la asignatura o programa optativo
     *
     * @param $data
     *
     * @return void
     *
     * @throws \Exception
     */
    public function proccessAddSubject($data)
    {
        switch ($data['type']){
            case 'optativa':
                $this->addOptative($data);
                break;
            case 'obligatoria':
                //TODO proceso para agregar asiganturas obligatorias
                break;
        }
    }

    /**
     * Cambio de optativa en la estructura
     *
     * @param $data
     * @return void
     * @throws \Exception
     */
    public function processUpdateOptative($data)
    {
        $programVersion = $this->getVersionProgram($data['program_abbr'], $data['program_version']);
        $oldOptativeProgramaVersion = $this->getVersionProgram($data['old_subject_abbr'], $data['old_subject_version']);
        $newOptativeProgramaVersion = $this->getVersionProgram($data['new_subject_abbr'], $data['new_subject_version']);

        /** @var NodoAcademico $ParentNode */
        $ParentNode = static::getNodeParent($programVersion);

        /** @var NodoAcademico $ParentNodeProgram */
        $ParentNodeProgram = static::getNodeParentOptativas($oldOptativeProgramaVersion, $ParentNode);

        /** @var NodoAcademico $newParentNodeProgram */
        $newParentNodeProgram = static::getNodeParent($newOptativeProgramaVersion);

        if (is_object($ParentNode) && is_object($ParentNodeProgram) && is_object($newParentNodeProgram)) {
            $fields = ['orden' => $ParentNodeProgram->orden, 'nombre' => $ParentNodeProgram->nombre];
            $this->updateStructure($ParentNode, $ParentNodeProgram, $newParentNodeProgram);
            if ($ParentNodeProgram->tipo != '_OPTATIVO') {
                $fields['tipo'] = '_OPTATIVO';
            }
            $ParentNodeProgram->guardar($fields);

            foreach ($data['organization_transformed_structure'] as $organizationAbbr) {
                $this->updateNodeResolution($programVersion, $organizationAbbr, $newParentNodeProgram, $newOptativeProgramaVersion);
            }
        } else {
            self::$response['errors'][] = 'No se pudo encontrar la estructura de la asignatura';
        }

    }

    /**
     * @param ProgramaVersion $programVersion
     * @param $programAbrreviation
     * @param NodoAcademico $newParentNodeProgram
     * @param ProgramaVersion $newOptativeProgramaVersion
     * @return void
     */
    public function updateNodeResolution(ProgramaVersion $programVersion, $organizationAbbr, NodoAcademico $newParentNodeProgram, ProgramaVersion $newOptativeProgramaVersion)
    {
        /** @var Resolucion $resolution */
        $resolution  = $this->getResolution($programVersion, $organizationAbbr);
        $transformedNodes = $resolution->getNodoTransformado()->NodosHijos;
        foreach ($transformedNodes as $transformedNode) {
            /** @var NodoAcademico $node */
            $node = $this->getTransformedNodeByNodoParent($transformedNode->id, $newParentNodeProgram->abreviatura);
            if (is_object($node)) {
                $fields = ['class_id' => $newOptativeProgramaVersion->id ,'creditos' => $newParentNodeProgram->creditos];
                $node->guardar($fields);
                self::logProccess("Se actualiza la transformada de {$organizationAbbr}: La optativa {$newParentNodeProgram->abreviatura} fue actualizada a la version {$newOptativeProgramaVersion->version}", 1);
            }
        }
    }

    /**
     * @param $programVersion
     * @param $sigla
     * @return mixed
     */
    public function getResolution($programVersion, $sigla)
    {
        return Resolucion::buscar([
            'programa_version_id' => $programVersion->id,
            'Convenio' => [
                'Organizacion' => [
                    'sigla' => $sigla
                ]
            ]
        ],[])->first();
    }

    /**
     * @param $nodoPadreId
     * @param $programAbbr
     * @return mixed
     */
    public function getTransformedNodeByNodoParent($nodoPadreId, $programAbbr)
    {
        return NodoTransformado::buscar([
            'class' => 'ProgramaVersion',
            'nodo_padre_id' => $nodoPadreId,
            'abreviatura' => $programAbbr
        ], [])->first();
    }

    /**
     * Trae a todas las inscripciones matriculadas en una version
     *
     * @param $abbreviature
     * @return mixed
     * @throws \Exception
     */
    public function getInscriptionsByProgramVersion($abbreviature)
    {
        /** @var $Inscriptions */
        $Inscriptions = $this->Loader->invoke('Inscripcion', 'buscar', [[
            'estado_id' => array(10, 150, 149, 29),
            'supera_optativas' => null,
            'ProgramaVersion' => [
                'Programa' => [
                    'abreviatura' => $abbreviature,
                ]
            ],
        ], []]);
        return $Inscriptions;
    }

    /**
     * Agrega una optativa a la inscripcion
     *
     * @param $data
     * @return bool
     * @throws \Exception
     */
    public function addOptative($data)
    {
        /** @var  $Inscriptions */
        $Inscriptions = $this->getInscriptionsByProgramVersion($data['program_abbr']);
        /** @var  $ProgramVersion */
        $ProgramVersion = Loader::invokeClass('ProgramaVersion', 'buscar', [[
            'version' => $data['program_version'],
            'Programa' => [
                'abreviatura' => $data['program_abbr'],
            ],
        ], []])->first();

        $OptativeProgramVersion = Loader::invokeClass('ProgramaVersion', 'buscar', [[
            'Programa' => [
                'abreviatura' => $data['abbr_new'],
            ],
        ], []])->first();

        foreach ($Inscriptions as $Inscription){

            if(!$this->hasOptative($Inscription->id,$OptativeProgramVersion->getId())){
                /** @var  $Optative */
                $Optative = new Especializacion();
                $Optative->_set([
                    'inscripcion_id' => $Inscription->id,
                    'programa_version_id' => $OptativeProgramVersion->getId(),
                    'creditos' => $OptativeProgramVersion->getCreditos()
                ]);

                /*** @var Admision $Admision */
                $Admision = $Inscription->Matriculas->first()->Admisiones->first();
                /** @var  $AcademicNodeOptative */
                $AcademicNodeOptative = $ProgramVersion->NodoAcademico->obtenerNodosHijosPorCriterios([
                    'class' => 'ProgramaVersion',
                    'class_id' => $OptativeProgramVersion->getId(),
                    'tipo' => '_OPTATIVO'
                ],[],0)->first();

                /** @var  $PlazaAcademica */
                $AcademicaSquare = PlazaAcademica::findOrCreate($Admision->getConvocatoria(),$AcademicNodeOptative);
                /** @var  $AcademicSelectionOptative */
                $AcademicSelectionOptative = SeleccionAcademica::create($AcademicaSquare, $Admision, []);
                $Optative->setSeleccionAcademica($AcademicSelectionOptative);
                $Optative->guardar();
            }
        }

        return $Optative->id > 0;
    }

    public function hasOptative($inscriptionId,$optativeProgramVersionId){
        $Optative = Loader::invokeClass('Especializacion', 'buscar', [[
            'inscripcion_id' => $inscriptionId,
            'programa_version_id' => $optativeProgramVersionId,
        ], []])->first();

        return $Optative->id > 0;
    }

    /**
     * Method that update the structure of the node to update the required subject
     * The subject must exist in the structure to make the change
     *
     * NOTE: This change only applies if there's no existing academic records for the subject.
     *
     * @param $data
     * @return void
     * @throws \Exception
     */
    public function processUpdateSubject($data)
    {
        $ProgramaVersion = $this->getVersionProgram($data['program_abbr'], $data['program_version']);

        /** @var NodoAcademico $ParentNode */
        $ParentNode = static::getNodeParent($ProgramaVersion);

        /** @var NodoAcademico $CurrentAcademicNode */
        $CurrentAcademicNode = $ParentNode->getChildNodesByAttrs([
            'class' => 'AsignaturaVersion',
            'abreviatura' => $data['abbr_current']])->first();

        /** @var NodoAcademico $NewAcademicNode */
        $NewAcademicNode = $ParentNode->getChildNodesByAttrs([
            'class' => 'AsignaturaVersion',
            'abreviatura' => $data['abbr_new']])->first();

        $this->updateStructure($ParentNode, $CurrentAcademicNode, $NewAcademicNode);
    }

    /**
     * Method that update the structure of the node to update the required subject
     * The subject must exist in the structure to make the change
     *
     * NOTE: This change only applies if there's no existing academic records for the subject.
     *
     * @param $data
     * @return void
     * @throws \Exception
     */
    public function processUpdateModuleSubject($data)
    {
        $ProgramaVersion = $this->getVersionProgram($data['program_abbr'], $data['program_version']);

        /** @var NodoAcademico $ParentNode */
        $ParentNodeProgram = static::getNodeParent($ProgramaVersion);

        /** @var NodoAcademico $CurrentAcademicNode */
        $ParentNode = $ParentNodeProgram->getChildNodesByAttrs([
            'class' => 'ProgramaVersion',
            'abreviatura' =>  $data['op_abbr']])->first();

        /** @var NodoAcademico $CurrentAcademicNode */
        $CurrentAcademicNode = $ParentNode->getChildNodesByAttrs([
            'class' => 'AsignaturaVersion',
            'abreviatura' => $data['abbr_current']])->first();

        /** @var NodoAcademico $NewAcademicNode */
        $NewAcademicNode = $ParentNode->getChildNodesByAttrs([
            'class' => 'AsignaturaVersion',
            'abreviatura' => $data['abbr_new']])->first();

        $this->updateModuleStructure($ParentNodeProgram,$ParentNode, $CurrentAcademicNode, $NewAcademicNode);
    }



    /**
     * Obtiene el nodo academico por la abreviatura
     *
     * @param $tipo
     * @param $abbr
     * @param ProgramaVersion $ProgramVersion
     *
     * @return mixed|void
     * @throws \Exception
     */
    public function getAcademicNodeByAbreviature($tipo, $abbr, ProgramaVersion $ProgramVersion)
    {

        switch ($tipo) {
            case 'asignatura':
                $AsignaturaVersion = $this->getSubjectVersionByAbbreviature($abbr);
                return static::obtenerNodoAcademicoPorProgramaVersionYAsignaturaVersion(
                    $ProgramVersion, $AsignaturaVersion)->first();
            case 'optativa':
                $ProgramVersionOptativo = $this->getProgramVersionOptativoByAbbreviature($abbr);
                return static::obtenerNodoAcademicoPorProgramaVersion(
                    $ProgramVersionOptativo, $ProgramVersion)->first();
        }


    }

    /**
     * Obtiene el programa version por la abreviatura y version dada
     *
     * @param $abreviatura
     * @param $version
     *
     * @return ProgramaVersion
     *
     * @throws \Exception
     */
    public function getVersionProgram($abreviatura, $version)
    {
        return Loader::invokeClass('ProgramaVersion', 'buscar', [[
            'version' => $version,
            'Programa' => [
                'abreviatura' => $abreviatura,

            ],
        ], []])->first();

    }

    /**
     * Obtiene el programa version optativo
     *
     * @param $abreviatura
     *
     * @return mixed
     *
     * @throws \Exception
     */
    public function getProgramVersionOptativoByAbbreviature($abreviatura)
    {
        return Loader::invokeClass('ProgramaVersion', 'buscar', [[
            'Programa' => [
                'abreviatura' => $abreviatura,

            ],
        ], []])->first();

    }

    /**
     * Obtiene la asignatura version
     *
     * @param $abreviatura
     *
     * @return mixed
     *
     * @throws \Exception
     */
    public function getSubjectVersionByAbbreviature($abreviatura)
    {
        return Loader::invokeClass('AsignaturaVersion', 'buscar', [[
            'Asignatura' => [
                'abreviatura' => $abreviatura,

            ],
        ], []])->first();

    }

    /**
     * Obtiene el Periodo Lectivo
     *
     * @param $name
     *
     * @return Model|Collection|\CTFramework\Framework\Database\ActiveRecord\Model|mixed|null
     */
    public function getTermByName($name)
    {
        return PeriodoLectivo::find([
            'where' => "nombre = '$name' AND nacceso = 'publico'"
        ])->first();
    }

    /**
     * Obtiene la convocatoria
     *
     * @param $announcementName
     * @param PeriodoLectivo|null $term
     * @return mixed
     * @throws \Exception
     */
    public function getCallByName($announcementName, PeriodoLectivo $term = null)
    {
        if(!$term)
            $term = PeriodosLectivos::getPeriodoLectivoDisponibleDefaultByClass('Matricula');

        return Loader::invokeClass('Convocatoria', 'buscar', [[
            'nombre' => $announcementName,
            'periodo_lectivo_id' => $term->id,
            'tipo' => '_SEMESTRE',
            'ciclo' => '_ORDINARIO',
            'nacceso' => 'publico',
        ], []])->first();

    }


    /**
     * Obtiene las inscripciones
     *
     * @param $abbreviature
     * @param PeriodoLectivo|null $term
     * @param ProgramaVersion $ProgramaVersionOptativo
     * @return mixed
     *
     * @throws \Exception
     */
    public function getInscriptions(
        $abbreviature,
        PeriodoLectivo $term = null,
        ProgramaVersion $ProgramaVersionOptativo
    )
    {
        if(!$term)
            $term = PeriodosLectivos::getPeriodoLectivoDisponibleDefaultByClass('Matricula');

        $Enrollments = $this->Loader->invoke('Inscripcion', 'buscar', [[
            'periodo_lectivo_id' => $term->id,

                'Especializaciones' => [

                    'programa_version_id' => $ProgramaVersionOptativo->id
                ],
                'Persona' => [
                ],
                'ProgramaVersion' => [
                    'Programa' => [
                        'abreviatura' => $abbreviature,
                    ]
                ],


        ], []]);

        return $Enrollments;
    }

    /**
     * Method that update the structure of the node
     *
     * @param NodoAcademico $ParentNode
     * @param NodoAcademico $CurrentAcademicNode
     * @param NodoAcademico $NewAcademicNode
     * @return void
     */
    public function updateStructure(NodoAcademico $ParentNode, NodoAcademico $CurrentAcademicNode, NodoAcademico $NewAcademicNode)
    {

        $existsRecords = $this->existsRecordsWithSubject($CurrentAcademicNode);

        if($existsRecords->count() > 0){
            return self::logProccess("Existen records con esta asignatura, no puede realizarse el cambio", 0);
        }

        if ($CurrentAcademicNode->class == 'AsignaturaVersion') {
            if (!$this->updateProgramCredits($ParentNode, $CurrentAcademicNode->creditos, $NewAcademicNode->creditos)) {
                self::logProccess("No se pudieron actualizar los creditos del programa", 0);
            }
        }

        if (!$this->transferNodeData($NewAcademicNode, $CurrentAcademicNode))
            self::logProccess("No se pudo reemplazar la data del nodo [{$CurrentAcademicNode->id}] con [{$NewAcademicNode->id}]", 0);

        if ($NewAcademicNode->nodo_padre_id) {
            $status = self::replaceParentNode($CurrentAcademicNode);
            if (!$status)
                self::logProccess("No se pudo actualizar el nodo padre del nodo [{$CurrentAcademicNode->id}]", 0);
        }

        $InscriptionsChanged = $this->getInscriptionsChanged($ParentNode->getElement());
        self::logProccess("Inscripciones afectadas [{$InscriptionsChanged->count()}]", 1);

        $InscriptionsChanged->map(function (Inscripcion $Inscription) {
            self::logProccess("Credencial de la fichas afectadas: [{$Inscription->getPersona()->getCredencialActiva()->getUserName()}]", 1);
        });
    }


    /**
     * Method that update the structure of the module node
     *
     * @param NodoAcademico $ParentNode
     * @param NodoAcademico $CurrentAcademicNode
     * @param NodoAcademico $NewAcademicNode
     * @return void
     */
    public function updateModuleStructure(NodoAcademico $ParentNodeProgram,
                                          NodoAcademico $ParentNode,
                                          NodoAcademico $CurrentAcademicNode,
                                          NodoAcademico $NewAcademicNode)
    {

        /** @var  $existsRecords */
        $existsRecords = $this->existsRecordsWithSubject($CurrentAcademicNode);

        if($existsRecords->count() > 0){
            return self::logProccess("Existen records con esta asignatura, no puede realizarse el cambio", 0);
        }

        if ($CurrentAcademicNode->class == 'AsignaturaVersion') {
            if (!$this->updateProgramCredits($ParentNode, $CurrentAcademicNode->creditos, $NewAcademicNode->creditos)) {
                self::logProccess("No se pudieron actualizar los creditos del programa", 0);
            }
        }

        if (!$this->transferNodeData($NewAcademicNode, $CurrentAcademicNode))
            self::logProccess("No se pudo reemplazar la data del nodo [{$CurrentAcademicNode->id}] con [{$NewAcademicNode->id}]", 0);

        if ($NewAcademicNode->nodo_padre_id) {
            $status = self::replaceParentNode($CurrentAcademicNode);
            if (!$status)
                self::logProccess("No se pudo actualizar el nodo padre del nodo [{$CurrentAcademicNode->id}]", 0);
        }

        /** @var  $InscriptionsChanged */
        $InscriptionsChanged = $this->getInscriptions($ParentNodeProgram->abreviatura, null, $ParentNode->getElement());
        self::logProccess("Inscripciones afectadas [{$InscriptionsChanged->count()}]", 1);

        foreach ($InscriptionsChanged as $Inscription) {
            self::logProccess("Credencial de la fichas afectadas: [{$Inscription->getPersona()->getCredencialActiva()->getUserName()}]", 1);
        }
    }

    /**
     * Method that verify if exists an academic record associate to the subject
     *
     * @param NodoAcademico $CurrentAcademicNode
     * @return \Illuminate\Support\Collection
     */
    public function existsRecordsWithSubject(NodoAcademico $CurrentAcademicNode)
    {
        return collect($CurrentAcademicNode->RecordsAcademicos);
    }

    /**
     * Method that update the program credits
     *
     * @param NodoEducativo $ParentNode
     * @param $subtractCredits
     * @param $addCredits
     * @return bool
     */
    public function updateProgramCredits(NodoEducativo $ParentNode, $subtractCredits, $addCredits)
    {
        $oldCredits = $ParentNode->creditos;
        $ParentNode->creditos = $oldCredits - $subtractCredits + $addCredits;
        $ParentNode->getElementoAcademico()->creditos = $oldCredits - $subtractCredits + $addCredits;
        if (!$ParentNode->save() or !$ParentNode->getElementoAcademico()->save())
            return false;
        if (!$ParentNode->nodo_padre_id)
            return true;
        else
            return self::updateProgramCredits($ParentNode->NodoPadre, $oldCredits, $ParentNode->creditos);
    }

    /**
     * Returns a collection of Inscriptions of the Program Version
     *
     * @param ProgramaVersion $ProgramaVersion
     * @return \Illuminate\Support\Collection
     */
    public function getInscriptionsChanged(ProgramaVersion $ProgramaVersion)
    {
        return collect($ProgramaVersion->Inscripciones->getArrayCopy());
    }


    /**
     * Method that replace the data of the old node to the new node
     *
     * @param NodoAcademico $originNode El nuevo nodo
     * @param NodoAcademico $destNode El nodo destino
     * @return bool
     */
    public function transferNodeData(NodoAcademico $originNode, NodoAcademico $destNode)
    {
        if ($originNode->class !== $destNode->class)
            return false;

        $destNode->nombre = $originNode->nombre;

        return $destNode->save() && $destNode->update_columns([
                'class_id' => $originNode->class_id,
                'tipo' => $originNode->tipo,
                'orden' => $originNode->orden,
                'abreviatura' => $originNode->abreviatura,
                'creditos' => $originNode->creditos,
            ]);
    }

    /**
     * Method that replace the Node Parent of the current academic node, so it won't appear in the structure
     *
     * @param NodoAcademico $CurrentAcademicNode
     * @return bool
     */
    public function replaceParentNode(NodoAcademico $CurrentAcademicNode)
    {

        return $CurrentAcademicNode->eliminar(true);
    }

    /**
     * Crea la seleccion academica
     *
     * @param $data
     * @param $Inscriptions
     * @param $Call
     * @param $AcademicSquare
     * @param NodoAcademico $NodeAcademic
     *
     * @return void
     *
     * @throws \Exception
     */
    public function createAcademicSelection(
        $data,
        $Inscriptions,
        $Call,
        $AcademicSquare,
        NodoAcademico $NodeAcademic
    )
    {
        if($Inscriptions->rows_total > 0)
        {
            foreach ($Inscriptions as $Inscription) {
                $inscripcionId = $Inscription->id;
                $existeSeleccionAcademica = $this->existeSeleccionAcademicaEnEstructura($NodeAcademic->id, $data);
                if (!$existeSeleccionAcademica) {
                    $Admission = Admision::getAdmisionPorConvocatoria($Inscription->Matricula, $Call);
                    $SeleccionAcademica = new SeleccionAcademica();
                    $SeleccionAcademica->admision_id = $Admission->id;
                    $SeleccionAcademica->plaza_academica_id = $AcademicSquare->id;
                    $SeleccionAcademica->estado_id = $SeleccionAcademica->getEstadoDefault()->id;
                    $status = $SeleccionAcademica->guardar();
                    if ($status) {
                        $this->updateEspecializacion($data, $inscripcionId, $SeleccionAcademica);
                    }
                    static::logProccess("Agregando Seleccion [{$SeleccionAcademica->id}]", $status);

                } else {
                    echo "Ya Existe Seleccion Academica";

                }
            }
        }else {
            echo "No hay inscripciones con esa asignatura a agregar.";

        }
    }

    /**
     * Metodo que verifica si existe la seleccion academica a agregar en la estructura.
     *
     * @param $nodoAcademicoId
     * @param $data
     * @return bool|void
     * @throws \Exception
     */
    public function existeSeleccionAcademicaEnEstructura($nodoAcademicoId, $data)
    {
        $NodoAcademico = $this->loadOrFail($nodoAcademicoId, 'NodoAcademico');

        if ($data['abbr_current'] == $NodoAcademico->getAbreviatura()) {
            return true;

        }
    }


    /**
     * Actualiza la especializacion
     *
     * @param $data
     * @param $inscripcionId
     * @param SeleccionAcademica $SeleccionAcademica
     *
     * @return void
     *
     * @throws \Exception
     */
    public function updateEspecializacion($data, $inscripcionId, SeleccionAcademica $SeleccionAcademica)
    {
        if ($data['type'] == "optativa") {
            $ProgramVersionOptativoCurrent = $this->getProgramVersionOptativoByAbbreviature($data['abbr_current']);
            $ProgramVersionOptativoNew = $this->getProgramVersionOptativoByAbbreviature($data['abbr_new']);

            $Especializacion = $this->getEspecializacionByInscripcionAndProgramVersion($inscripcionId, $ProgramVersionOptativoCurrent->id);

            if ($Especializacion->id) {
                $status = $Especializacion->update([
                    'programa_version_id' => $ProgramVersionOptativoNew->id,
                    'seleccion_academica_id' => $SeleccionAcademica->id,
                    'fecha_modificacion' => date('Y-m-d H:i:s')
                ]);
            }
        }

    }


    /** Muestra el log del proceso de la ejecucion
     *
     * @param $step
     * @param $status
     *
     * @return void
     */
    public static function logProccess($step, $status){
        static::$response["steps"][] = "$step|$status";
        static::$response["status"] = static::$response["status"] && $status;

        if(!$status){
            static::$response["errors"][] = $step;
        }
    }

    /**
     * Obtiene el nodo academico por programa version
     *
     * @param ProgramaVersion $ProgramaVersionOptativo
     * @param ProgramaVersion $ProgramVersion
     *
     * @return Collection
     */
    public static function obtenerNodoAcademicoPorProgramaVersion(
        ProgramaVersion $ProgramaVersionOptativo, ProgramaVersion $ProgramVersion)
    {
        $NodoPadre = static::getNodeParent($ProgramVersion);

        if ($NodoPadre->id) {

            return NodoAcademico::buscar([

                'nodo_padre_id' => $NodoPadre->id,
                'class' => 'ProgramaVersion',
                'class_id' => $ProgramaVersionOptativo->id,
            ], []);
        }
    }

    /** Obtiene el nodo padre
     *
     * @param ProgramaVersion $ProgramaVersion
     *
     * @return Collection
     */
    public static function getNodeParent(ProgramaVersion $ProgramaVersion)
    {

        return NodoAcademico::buscar([

            'tipo' => '_OBLIGATORIO',
            'class' => 'ProgramaVersion',
            'class_id' => $ProgramaVersion->id,
        ], [])->first();
    }

    /**
     * @param ProgramaVersion $ProgramaVersion
     * @param NodoAcademico|null $academicNode
     * @return mixed
     */
    public static function getNodeParentOptativas(ProgramaVersion $ProgramaVersion, NodoAcademico $academicNode = null)
    {
        return NodoAcademico::buscar([
            'tipo' => '_OPTATIVO',
            'class' => 'ProgramaVersion',
            'class_id' => $ProgramaVersion->id,
            'nodo_padre_id' => $academicNode->id ?: null
        ], [])->first();
    }


    /**
     * Obtiene el Nodo academico de asignatura version
     *
     * @param ProgramaVersion $ProgramaVersion
     * @param AsignaturaVersion $AsignaturaVersion
     *
     * @return Collection
     */
    public static function obtenerNodoAcademicoPorProgramaVersionYAsignaturaVersion(
        ProgramaVersion $ProgramaVersion, AsignaturaVersion $AsignaturaVersion)
    {

        return NodoAcademico::buscar([
            'NodoEducativoPadre|NodoNivelForPri' => [
                'NodoEducativoPadre|NodoNivelForSeg' => [
                    'NodoEducativoPadre|NodoProgVer' => [
                        'Element@ProgramaVersion' => [
                            'id' => $ProgramaVersion->id,
                        ],
                    ],
                ],
            ],
            'class' => 'AsignaturaVersion',
            'class_id' => $AsignaturaVersion->id,
        ], []);
    }




    /**
     * Obtiene la especializacion por la inscripcion y el programa version
     *
     * @param $inscripcionId
     * @param $programaVersionId
     *
     * @return mixed
     *
     * @throws \Exception
     */
    public function getEspecializacionByInscripcionAndProgramVersion($inscripcionId, $programaVersionId)
    {
        return Loader::invokeClass('Especializacion', 'buscar', [[

                'inscripcion_id' => $inscripcionId,
                'programa_version_id' => $programaVersionId,

        ], []])->first();

    }

        public function verifySubjectGradeTransfer($data)
        {
            $ProgramaVersion = $this->getVersionProgram($data['program_abbr'], $data['program_version']);
            $ParentNode = static::getNodeParent($ProgramaVersion);

            // Obtener nodos académicos de la asignatura original y la nueva
            $CurrentAcademicNode = $ParentNode->getChildNodesByAttrs([
                'class' => 'AsignaturaVersion',
                'abreviatura' => $data['subject_abbr'] ?? $data['abbr_current']
            ])->first();
            $NewAcademicNode = $ParentNode->getChildNodesByAttrs([
                'class' => 'AsignaturaVersion',
                'abreviatura' => $data['new_subject_abbr'] ?? $data['abbr_new']
            ])->first();

            if (!$CurrentAcademicNode || !$NewAcademicNode) {
                self::$response['errors'][] = 'No se encontraron ambos nodos académicos para la verificación.';
                self::$response['status'] = false;
                return self::$response;
            }

            // Mapear registros por inscripción
            $oldRecords = [];
            foreach ($CurrentAcademicNode->RecordsAcademicos as $record) {
                $oldRecords[$record->inscripcion_id] = $record;
            }
            $newRecords = [];
            foreach ($NewAcademicNode->RecordsAcademicos as $record) {
                $newRecords[$record->inscripcion_id] = $record;
            }

            $errores = [];
            $verificados = 0;
            $total = count($oldRecords);
            foreach ($oldRecords as $inscripcion_id => $oldRecord) {
                if (!isset($newRecords[$inscripcion_id])) {
                    $errores[] = "No existe registro trasladado para la inscripción $inscripcion_id";
                    continue;
                }
                $newRecord = $newRecords[$inscripcion_id];
                // Comparar campos principales
                if ($oldRecord->calificacion != $newRecord->calificacion || $oldRecord->estado != $newRecord->estado) {
                    $errores[] = "Diferencia en inscripción $inscripcion_id: calificación/estado no coinciden (ant: {$oldRecord->calificacion}/{$oldRecord->estado}, nuevo: {$newRecord->calificacion}/{$newRecord->estado})";
                } else {
                    $verificados++;
                }
            }

            self::$response['steps'][] = "Verificados $verificados de $total traslados de notas.";
            if ($errores) {
                self::$response['errors'] = array_merge(self::$response['errors'], $errores);
                self::$response['status'] = false;
            }
            return self::$response;
        }
}